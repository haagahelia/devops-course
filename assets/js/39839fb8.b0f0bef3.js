"use strict";(self.webpackChunkdevops=self.webpackChunkdevops||[]).push([[423],{2626:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/failed_test-39da4c2338edcf89752116d6d8baa0e9.png"},2717:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/auto_deploy-c1906e88ebd40fb26c7f91b59c0b9a71.png"},3298:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"deployment/deployment","title":"CD pipeline","description":"Deployment","source":"@site/docs/deployment/deployment.md","sourceDirName":"deployment","slug":"/deployment/","permalink":"/devops-course/docs/deployment/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/deployment/deployment.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"CD pipeline"},"sidebar":"tutorialSidebar","previous":{"title":"Deployment & Delivery","permalink":"/devops-course/docs/deployment/general"},"next":{"title":"Deployment using containers","permalink":"/devops-course/docs/deployment/deploymentContainers"}}');var o=t(4848),i=t(8453);const r={sidebar_position:2,title:"CD pipeline"},l=void 0,a={},d=[{value:"Deployment",id:"deployment",level:3},{value:"CI/CD Pipeline",id:"cicd-pipeline",level:3},{value:"Triggering manually",id:"triggering-manually",level:3},{value:"Environments",id:"environments",level:3},{value:"Further reading",id:"further-reading",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h3,{id:"deployment",children:"Deployment"}),"\n",(0,o.jsxs)(n.p,{children:["We will do our first deployment to Render.com (",(0,o.jsx)(n.a,{href:"https://render.com",children:"https://render.com"}),") that provides free Hobby plan for small-scale applications. There are some limitations in free plan that you should be aware. The deployments are much slower when using free plan and free instances will spin down with inactivity, which can delay requests by 50 seconds or more. We are going to deploy the Node Express app that we used in the CI pipelines chapter earlier."]}),"\n",(0,o.jsx)(n.p,{children:"In this chapter, we continue working with the calculator Node.js application introduced in the CI workflow section."}),"\n",(0,o.jsxs)(n.p,{children:["First, you have to create an account to Render.com in ",(0,o.jsx)(n.a,{href:"https://dashboard.render.com/register",children:"https://dashboard.render.com/register"}),". After you have sign-in to Render, select ",(0,o.jsx)(n.strong,{children:"New --\x3e Web Service"})," in your workspace."]}),"\n",(0,o.jsxs)(n.p,{children:["Next, you can select public GitHub repository where your project is hosted and press the ",(0,o.jsx)(n.strong,{children:"Connect"})," button (Use your own forked repository)."]}),"\n",(0,o.jsx)(n.p,{children:"In the web service form, fill in the following details:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Field"}),(0,o.jsx)(n.th,{children:"Value"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Language"}),(0,o.jsx)(n.td,{children:"Node"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Branch"}),(0,o.jsx)(n.td,{children:"main"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Build command"}),(0,o.jsx)(n.td,{children:"npm install"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Start command"}),(0,o.jsx)(n.td,{children:"npm start"})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["In the Instance Type select ",(0,o.jsx)(n.strong,{children:"Free"})," option"]}),"\n",(0,o.jsxs)(n.p,{children:["Finally, press the ",(0,o.jsx)(n.strong,{children:"Deploy"})," button. After the deployment starts, you will be redirected to a page where you can see the deployment log. Wait until, you get the message that your service is live:"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Render.com deployment log",src:t(8696).A+"",width:"840",height:"364"})}),"\n",(0,o.jsx)(n.p,{children:"As you can see the deployment to modern hosting providers is really straigthforward."}),"\n",(0,o.jsxs)(n.p,{children:["By default, Render automatically deploys your service whenever you update its code in linked GitHub repository. Opent the ",(0,o.jsx)(n.code,{children:"app.ts"})," file and change the message that is displayed when you navigate to the root endpoint:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"app.get('/', (req, res) => {\n  res.json({ message: 'Calculator API is running on Render.com' });\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"Push your changes to the repository and see that the GitHub actions workflow fails."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Failed test",src:t(2626).A+"",width:"1042",height:"313"})}),"\n",(0,o.jsxs)(n.p,{children:["One of the tests does not pass, yet the application is still automatically deployed to Render.com. ",(0,o.jsx)(n.strong,{children:"Deployments should only occur after all linting and tests have successfully passed."}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"cicd-pipeline",children:"CI/CD Pipeline"}),"\n",(0,o.jsxs)(n.p,{children:["In this phase we will modify our GitHub actions workflow so that deployment is done only after linting and tests are passed. We will use web hooks to trigger deployment after linting and tests are passed. If you are not familiar with web hooks you can read more ",(0,o.jsx)(n.a,{href:"https://www.redhat.com/en/topics/automation/what-is-a-webhook",children:"here"}),". The instructions to use web hooks for the deployment in Render.com can be found ",(0,o.jsx)(n.a,{href:"https://render.com/docs/deploy-hooks",children:"here"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["First, we will disable automatic deployment from the Render.com web service. Navigate to the settings page of your web service and select ",(0,o.jsx)(n.strong,{children:"No"})," from the ",(0,o.jsx)(n.strong,{children:"Auto-Deploy"}),"."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Auto deployment",src:t(2717).A+"",width:"1254",height:"169"})}),"\n",(0,o.jsxs)(n.p,{children:["Next, we have to get hook url. Navigate to your Render.com web service's settings and scroll down to ",(0,o.jsx)(n.strong,{children:"Deploy Hook"}),". Copy your private hook url and remember to keep that secret."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Deploy hook",src:t(6297).A+"",width:"1255",height:"205"})}),"\n",(0,o.jsxs)(n.p,{children:["To securely use the deployment hook URL in your GitHub Actions workflow, you should store it as a secret. Navigate to your repository's settings, and from the left-side menu, select ",(0,o.jsx)(n.strong,{children:"Secrets and variables"}),". Create a new ",(0,o.jsx)(n.strong,{children:"Repository secret"}),", name it ",(0,o.jsx)(n.code,{children:"RENDER_DEPLOY_HOOK_URL"}),", and paste the deployment hook URL you copied from Render.com into the secret value field. Finally, click the ",(0,o.jsx)(n.strong,{children:"Add Secret"})," button to save it."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Github secrets",src:t(7332).A+"",width:"1657",height:"372"})}),"\n",(0,o.jsxs)(n.p,{children:["You can read more about secrets ",(0,o.jsx)(n.a,{href:"https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions",children:"here"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Now, we can  modify our Github actions workflow. Add the following Deploy step in your GitHub Actions workflow. It is responsible for triggering a deployment to the Render.com using a deployment hook URL."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"# Node.js CI/CD pipeline\nname: Node.js CI/CD\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n    \njobs:\n  Node-ci-pipeline:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with: \n          node-version: '20'\n      - name: Install dependencies\n        run: npm ci\n      - name: Linting\n        run: npm run lint\n      - name: Run tests\n        run: npm run test\n      - name: Build\n        run: npm run build\n      //highlight-start\n      # Deployment to Render.com\n      - name: Deploy\n        env:\n          deploy_url: ${{ secrets.RENDER_DEPLOY_HOOK_URL }}\n        run: |\n          curl \"$deploy_url\"   \n     //highlight-end\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"deploy_url"})," is set using a secret stored in your GitHub repository (",(0,o.jsx)(n.code,{children:"RENDER_DEPLOY_HOOK_URL"}),").\nSecrets are securely stored and not exposed in logs, ensuring sensitive information like deployment URLs or API keys remains protected."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"curl"})," command is used to make an HTTP request to the deployment hook URL (",(0,o.jsx)(n.code,{children:"$deploy_url"}),").\nThis triggers a deployment process on a Render, which listens for such hooks to start deploying the latest version of your application."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Once the deployment is triggered, navigate to the ",(0,o.jsx)(n.strong,{children:"Events"})," section in your Render.com web service dashboard. Here, you should see a new deployment event. After the deployment completes, the latest version of your application will be live."]}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsxs)(n.p,{children:["In the previous example, deployment is triggered for both pushes and pull requests. However, we only want to deploy when code is pushed directly to the ",(0,o.jsx)(n.code,{children:"main"})," branch. To achieve this, you can use the ",(0,o.jsx)(n.code,{children:"if"})," condition to ensure deployment runs only on pushes to ",(0,o.jsx)(n.code,{children:"main"}),"."]}),(0,o.jsxs)(n.p,{children:["We also use ",(0,o.jsx)(n.code,{children:"needs"})," to specify that the ",(0,o.jsx)(n.code,{children:"deploy"})," job should only run after the ",(0,o.jsx)(n.code,{children:"ci"})," job has completed successfully. This ensures that deployment only happens if all previous steps\u2014such as linting, building, and testing\u2014have passed."]})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"name: Node.js CI/CD\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n    \njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with: \n          node-version: '20'\n      - name: Install dependencies\n        run: npm ci\n      - name: Linting\n        run: npm run lint\n      - name: Run tests\n        run: npm test\n      - name: Build\n        run: npm run build\n  \n  //highlight-start\n  deploy:\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n    needs: ci\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to Render\n        env:\n          DEPLOY_URL: ${{ secrets.RENDER_DEPLOY_HOOK_URL }}\n        run: curl -X POST \"$DEPLOY_URL\"\n  //highlight-end\n"})}),"\n",(0,o.jsx)(n.p,{children:"A common practice is that linters and tests are often run in the same workflow, but deployment is kept in a separate workflow. This way you get a clean separation, where one workflow handles lint/tests and another handles deployment only after the first one is green."}),"\n",(0,o.jsx)(n.p,{children:"In our case workflows could be the following:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'title="CI workflow"',children:"name: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n    \njobs:\n  Node-ci-pipeline:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with: \n          node-version: '20'\n      - name: Install dependencies\n        run: npm ci\n      - name: Linting\n        run: npm run lint\n      - name: Run tests\n        run: npm run test\n      - name: Build\n        run: npm run build        \n"})}),"\n",(0,o.jsxs)(n.p,{children:["We want to make sure that the deploy runs only if the CI has passed. We can use the ",(0,o.jsx)(n.code,{children:"workflow_run"})," trigger in the deployment workflow."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'title="CD workflow"',children:"name: CD\n\non:\n  workflow_run:\n    workflows: [\"CI\"]\n    types:\n      - completed\n    \njobs:\n  deploy:\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy\n        env:\n          deploy_url: ${{ secrets.RENDER_DEPLOY_HOOK_URL }}\n        run: |\n          curl \"$deploy_url\"   \n"})}),"\n",(0,o.jsx)(n.h3,{id:"triggering-manually",children:"Triggering manually"}),"\n",(0,o.jsx)(n.p,{children:"Sometimes you want a workflow that only runs when a human explicitly tells it to run. This is common when you want to perform deployments manually, run maintenance scripts, or trigger jobs that should not happen automatically on every push or pull request. For example, you might want to deploy to production only after verifying everything in a staging environment, or run a database migration script as needed."}),"\n",(0,o.jsxs)(n.p,{children:["This is done with the ",(0,o.jsx)(n.code,{children:"workflow_dispatch"})," event in your workflow file:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"on:\n  workflow_dispatch:\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Read more about ",(0,o.jsx)(n.code,{children:"workflow_dispatch"})," in ",(0,o.jsx)(n.a,{href:"https://docs.github.com/en/actions/reference/workflows-and-actions/events-that-trigger-workflows#workflow_dispatch",children:"Github documentation"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"environments",children:"Environments"}),"\n",(0,o.jsxs)(n.p,{children:["Environments are named deployment targets that represent different stages of your application's lifecycle, such as ",(0,o.jsx)(n.code,{children:"development"}),", ",(0,o.jsx)(n.code,{children:"staging"}),", and ",(0,o.jsx)(n.code,{children:"production"}),". They help you manage deployments, apply environment-specific protection rules, and control access to sensitive resources."]}),"\n",(0,o.jsx)(n.p,{children:"In GitHub Actions, you can define environments in your repository settings. Each environment can have specific secrets, required reviewers, and deployment branch restrictions. This allows you to enforce approval workflows or add manual checks before deploying to critical environments like production."}),"\n",(0,o.jsxs)(n.p,{children:["To use environments in your workflow, specify the ",(0,o.jsx)(n.code,{children:"environment"})," key in your deployment job:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'jobs:\n  deploy:\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: Deploy\n        run: echo "Deploying to production"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["You can also set up environment-specific secrets (e.g., ",(0,o.jsx)(n.code,{children:"RENDER_DEPLOY_HOOK_URL"}),") that are only available to jobs running in that environment. This helps keep sensitive information secure and ensures that only approved workflows can access production credentials."]}),"\n",(0,o.jsxs)(n.p,{children:["Read more about environments in the ",(0,o.jsx)(n.a,{href:"https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment",children:"GitHub Actions documentation"}),"."]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h3,{id:"further-reading",children:"Further reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"https://docs.github.com/en/actions/about-github-actions/about-continuous-deployment-with-github-actions",children:"https://docs.github.com/en/actions/about-github-actions/about-continuous-deployment-with-github-actions"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},6297:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/deploy_hook-92ce2bb037e056af7c5092eb26db0586.png"},7332:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/github_secret-65c212cec72a1879df0f47025659dd25.png"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},8696:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/deployment_log-e473107d0ba98c8fdfba34131e3a447d.png"}}]);