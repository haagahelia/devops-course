"use strict";(self.webpackChunkdevops=self.webpackChunkdevops||[]).push([[97],{4347:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"monitoring/secrets","title":"Secrets","description":"When working with CI/CD pipelines, it\'s common to need credentials or API keys\u2014for example, to deploy to a cloud provider or access third-party services. Storing these securely is critical. GitHub Secrets provides a secure way to store and manage sensitive data like when using GiHub actions. Each CI/CD platform has its own way of managing secrets.","source":"@site/docs/monitoring/secrets.md","sourceDirName":"monitoring","slug":"/monitoring/secrets","permalink":"/devops-course/docs/monitoring/secrets","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/monitoring/secrets.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Secrets"},"sidebar":"tutorialSidebar","previous":{"title":"Security","permalink":"/devops-course/docs/monitoring/security"},"next":{"title":"Final Project","permalink":"/devops-course/docs/category/final-project"}}');var i=t(4848),r=t(8453);const o={sidebar_position:5,title:"Secrets"},a=void 0,c={},l=[{value:"Github Secrets",id:"github-secrets",level:3},{value:"Using Secrets in Workflows",id:"using-secrets-in-workflows",level:3},{value:"Gitleaks",id:"gitleaks",level:3},{value:"Further Reading",id:"further-reading",level:3}];function d(e){const s={a:"a",code:"code",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"When working with CI/CD pipelines, it's common to need credentials or API keys\u2014for example, to deploy to a cloud provider or access third-party services. Storing these securely is critical. GitHub Secrets provides a secure way to store and manage sensitive data like when using GiHub actions. Each CI/CD platform has its own way of managing secrets."}),"\n",(0,i.jsx)(s.h3,{id:"github-secrets",children:"Github Secrets"}),"\n",(0,i.jsx)(s.p,{children:"GitHub supports storing secrets at different levels:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Repository-level secrets: Specific to a single repository."}),"\n",(0,i.jsx)(s.li,{children:"Environment-level secrets: Used within specific environments (e.g., production, staging)."}),"\n",(0,i.jsx)(s.li,{children:"Organization-level secrets: Shared across multiple repositories."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"In this course we are using repository-level secrets."}),"\n",(0,i.jsx)(s.p,{children:"How to Add a Secret:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Go to your repository on GitHub."}),"\n",(0,i.jsxs)(s.li,{children:["Click ",(0,i.jsx)(s.strong,{children:"Settings"})," > ",(0,i.jsx)(s.strong,{children:"Secrets and variables"})," > ",(0,i.jsx)(s.strong,{children:"Actions"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Click ",(0,i.jsx)(s.strong,{children:"New repository secret"}),"."]}),"\n",(0,i.jsx)(s.li,{children:"Name your secret (e.g., API_KEY) and type the secret value."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"using-secrets-in-workflows",children:"Using Secrets in Workflows"}),"\n",(0,i.jsxs)(s.p,{children:["You can use secrets in your workflow .yml file with the ",(0,i.jsx)(s.code,{children:"secrets"})," context."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:'jobs:\n  build-and-run:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Run the app\n        //highlight-start\n        env:\n          API_KEY: ${{ secrets.API_KEY }}\n        //highlight-end\n        run: |\n          echo "Running the app..."\n          node app.js\n'})}),"\n",(0,i.jsx)(s.p,{children:"Never hard-code secrets in your code or workflow files. You should also limit secret scope. Use environment or repo-level secrets as needed."}),"\n",(0,i.jsx)(s.p,{children:"Secrets are not injected into your application directly by GitHub. Instead, they are exposed to the runtime environment, and your application accesses them using environment variables."}),"\n",(0,i.jsx)(s.p,{children:"In your application code, you access it using your language's environment variable access method. For example,"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-js",metastring:'title="Node.js"',children:"const apiKey = process.env.API_KEY;\n"})}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",metastring:'title="Python"',children:'import os\napi_key = os.getenv("API_KEY")\n'})}),"\n",(0,i.jsx)(s.h3,{id:"gitleaks",children:"Gitleaks"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.a,{href:"https://gitleaks.io/",children:"Gitleaks"})," open-source (MIT license) tool for detecting hardcoded secrets in your Git repositories. It's like a security guard that scans your commits, branches, and pull requests to ensure sensitive data (like API keys, passwords, or tokens) doesn\u2019t accidentally leak into version control."]}),"\n",(0,i.jsxs)(s.p,{children:["It works by using regex-based rules. You can define a ",(0,i.jsx)(s.code,{children:"gitleaks.toml"})," file to customize what patterns to scan, whitelist safe matches, or add custom secret formats. Read more about configuration format ",(0,i.jsx)(s.a,{href:"https://github.com/gitleaks/gitleaks?tab=readme-ov-file#configuration",children:"here"}),". You can use Gitleaks playground (",(0,i.jsx)(s.a,{href:"https://gitleaks.io/playground",children:"https://gitleaks.io/playground"}),") rule wizard to generate rules."]}),"\n",(0,i.jsx)(s.p,{children:"Goal is to automate security checks before code is merged or deployed, and to catch sensitive data leaks as early as possible in CI pipeline."}),"\n",(0,i.jsxs)(s.p,{children:["Here\u2019s an example of a GitHub Actions workflow that runs Gitleaks using the official ",(0,i.jsx)(s.code,{children:"gitleaks/gitleaks-action@v2"}),". This action provides a simple way to integrate secret scanning directly into your CI pipeline."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-yaml",children:"name: Secret Scan\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n\njobs:\n  gitleaks:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0  # Needed to scan full commit history\n\n      - name: Run Gitleaks\n        uses: gitleaks/gitleaks-action@v2\n        with:\n          config-path: .github/gitleaks.toml  # Optional custom config\n          fail: true  # Fail the job if leaks are found\n"})}),"\n",(0,i.jsx)(s.p,{children:"Workflow triggers on push or pull requests that ensures secrets are caught early before merging to main."}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h3,{id:"further-reading",children:"Further Reading"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://docs.github.com/en/actions/security-for-github-actions/security-guides/about-secrets",children:"https://docs.github.com/en/actions/security-for-github-actions/security-guides/about-secrets"})}),"\n"]})]})}function u(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>a});var n=t(6540);const i={},r=n.createContext(i);function o(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);